一、堆
1 基本概念
	1.	定义（英文：heap）
可以迅速找到一堆树中的最大或者最小值的数据结构。
大顶堆/大根堆：根节点最大的堆
小顶堆/小根堆：根节点最小的堆
	1.	时间复杂度：


	1.	性质
	•	通过完全二叉树来实现
	•	最大堆的性质：
	◦	性质1:是一颗完全树（除了叶子结点其他都是完整的）
	◦	性质2:树中任意节点的值总是 >=其子节点的值
	1.	实现细节
	•	一般通过数组实现：
	•	假设“第一个元素”在数组下标为0的话，则
	◦	索引为i的左孩子的索引：2*i+1
	◦	索引为i的右孩子的索引：2*i+2
	◦	索引为i的父节点的索引：(i-1)/2

 2 基本操作
数组实现堆：
	1.	插入
	2.	删除队顶元素
	3.	Java中直接调priority_queue
	4.	做题中通常用PriorityQueue方法new对象
二、DFS 和BFS代码模板
三、递归
	1.	概念 
递归就是自己调用自己，每次调用时传入不同的变量。
先向下层递，再一层层回到上层，归去来兮的感觉。
	2.	代码模板
	•	思维要点：
	◦	 不要人肉进行递归
可以刚开始画树状图，后期最好直接写。
	◦	找到最近最简方法，将其拆解成可重复解决的问题（找最近重复子问题）。
	◦	数学归纳法的思想
四、二叉树
	1.	链表就是特殊化的树
		树是特殊化的图
		叶子结点：结束末尾
	2.	树结点的定义
	3.	应用
		递归树、棋类游戏
	4.	树的遍历
		递归调用——为什么？——树的定义没有一个遍于循环的结构，更多的是左结点右结点，所以		要访问子树一般用相同的方法结构，所以采用递归更合适。
		前序preorder：根左右
		中序inorder：左根右
		后序postorder：左右根
		代码模板（背会）
	5.	二叉搜索树（BST）
		常见操作
			1）查询   O(logn) 
				先从根节点开始比较，类似二分查找
			2）插入（创建）   O(logn) 
				最后停留的位置就是要插入的地方
			3）删除
				叶节点直接删除；
				根节点或子树根节点，拿和它数值上（不是位置上）最接近的节点充当它的位置，				一般取值为第一个大于它的结点，把它替换上去。
			最差时间复杂度：当树退化成一根棍子（即单链表）时，时间复杂度为O(n)。
	6..	平衡二叉树
		•概念：
			它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，左右两个子树都是一棵平			衡二叉树。
			优点：这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时			间复杂度最好情况和最坏情况都维持在O(logN)。
		•节点之间的大小关系（同二叉搜索树）：根节点一定大于左子节点，一定小于右子节点





